/*
Inspired by Daniel Shiffman
http://codingtra.in
https://www.youtube.com/watch?v=z0YFFg_nBjw
https://github.com/CodingTrain/QuadTree
*/


import kit.math;
include "string.h";
include "time.h";
include "stdlib.h";
include "stdio.h";
include "math.h";
// var count: Int = 0;


function absF(n: Float) {
    if n < 0 {
        return n * -1;
    } else {
        return n;
    }
}


function strAdd(one: CString, two: CString) {
    var out = malloc(one.length + two.length + 1);
    strcpy(out, one);
    strcat(out, two);
    return out;
}


function randF(lower: Float, upper: Float) {
    // printf("%lu", clock());
    srand48(clock());
    return lower + drand48() * (upper - lower);
}


const pi: Float = 3.14159265358979;

function sign(x: Float): Float {
    if (x < 0) {
        return -1;
    }
    if (x > 0) {
        return 1;
    }
    return 0;
}

// cotangent
function cot(x: Float): Float {
    return tan(pi/2 - x);
}


function radian_PosNeg_To_0to2pi(angle: Float) {
    if (angle < 0) {
        return (2 * pi) - angle;
    } else {
        return angle;
    }
}


function rectDist(angle: Float, rect: Rect): Float {
    // angle should be within [0, 2*pi) range
    // x and y point to the _middle_ of the rectangle
    var x: Float = rect.center.x;
    var y: Float = rect.center.y;
    var width: Float = rect.w;
    var height: Float = rect.h;
    var base_angle: Float = atan(height/width);
    // the angle between rectangle diagonal and Ox axis
    var px: Float;
    var py: Float;
    // Which side we're on?
    var left: Bool = (fabs(angle - pi) < base_angle);
    var right: Bool = (angle > 2 * pi-base_angle || angle < base_angle);
    var top: Bool = (fabs(angle - pi / 2) <= fabs(pi / 2 - base_angle));
    var bottom: Bool = (fabs(angle - 3 * pi / 2) <= fabs(pi / 2 - base_angle));
    // The helper values used to adjust sides
    var lr: Int = (if left then -1 else 0) + (if right then 1 else 0);
    var tb: Int = (if bottom then -1 else 0) + (if top then 1 else 0);
    if (lr != 0) {
                    // we're on vertical edge of rectangle
                    px = x + width / 2 * lr;
                    py = y + width / 2 * tan(angle) * lr;
    } else {
                    // we're on the horizontal edge or in the corner
                    px = x + height / 2 * cot(angle) * tb;
                    py = y + height / 2 * tb;
    }
    return sqrtf((px - x) * (px - x)
                +
                (py - y) * (py - y)
                );
}


struct Point {
    var x: Float;
    var y: Float;
    var initialized: Bool = false;

    static function new(x: Float, y: Float) {
        return struct Self {
            x,
            y,
            initialized: true
        };
    }

    function dist(other: Point): Float {
        return sqrtf((this.x - other.x) * (this.x - other.x)
                    +
                    (this.y - other.y) * (this.y - other.y)
                    );
    }

    function print(printUnInit: Bool = true, append: CString = "") {
        if this.initialized {
            printf("(%f, %f)", this.x, this.y);
            printf("%s", append);
        } else {
            if printUnInit {
                printf("(-.---, -.---)");
                printf("%s", append);
            }
        }
    }

    rules {
        (${one: Point} - ${two: Point}) => Point.new($one.x - $two.x, $one.y - $two.y);
        (${one: Point} + ${two: Point}) => Point.new($one.x + $two.x, $one.y + $two.y);
        (${one: Point} * ${two: Point}) => Point.new($one.x * $two.x, $one.y * $two.y);
        (${one: Point} / ${two: Point}) => Point.new($one.x / $two.x, $one.y / $two.y);
        (${one: Point} % ${two: Point}) => Point.new($one.x % $two.x, $one.y % $two.y);
        (${one: Point} ** ${two: Point}) => Point.new(pow($one.x, $two.x), pow($one.y, $two.y));
        (atan2(${pt: Point})) => atan2($pt.x, $pt.y);
    }
}


trait Bound {
    function dist(other: Box[Bound]): Float;
    function contains(pt: Point): Bool;
    function intersects(other: Box[Bound]): Bool;
    function print(): Void;
    function type(): CString;
    public function base(): Ptr[Void]{
        return &this;
    }
}


struct Rect {
    var x: Float;
    var y: Float;
    var w: Float;
    var h: Float;

    var tl: Point;
    var tr: Point;
    var bl: Point;
    var br: Point;

    var center: Point;

    static function new(x: Float, y: Float, w: Float, h: Float): Rect {
        return struct Self {
            x,
            y,
            w,
            h,
            tl: Point.new(x,     y    ),
            tr: Point.new(x + w, y    ),
            bl: Point.new(x,     y + h),
            br: Point.new(x + w, y + h),
            center: Point.new(x + (w / 2), y + (h / 2))
        };
    }

    public function base(): Ptr[Void]{
        return &this;
    }
}

implement Bound for Rect {
    function contains(pt: Point): Bool {
        return (pt.x >= this.x - this.w &&
                pt.x <= this.x + this.w &&
                pt.y >= this.y - this.h &&
                pt.y <= this.y + this.h);
    }

    function dist(other: Box[Bound]): Float {
        if other.type() == "rect" {
            var otherRect = other.base() as Ptr[Rect];
            var angle_thisToOther = radian_PosNeg_To_0to2pi(atan2(this.center - otherRect.center));
            var angle_otherToThis = radian_PosNeg_To_0to2pi(atan2(otherRect.center - this.center));
            var dist_tl = this.tl.dist(otherRect.tl);
            var dist_tr = this.tr.dist(otherRect.tr);
            var dist_bl = this.bl.dist(otherRect.bl);
            var dist_br = this.br.dist(otherRect.br);
            return (dist_tl + dist_tr + dist_bl + dist_br) / 4;
        }
        if other.type() == "circle" {
            var otherCircle: Ptr[Circle] = other.base() as Ptr[Circle];
            var thisRect: Ptr[Rect] = this.base() as Ptr[Rect];
            var angle_thisToOther = radian_PosNeg_To_0to2pi(atan2(thisRect.center - otherCircle.center));
            // var angle_otherToThis = radian_PosNeg_To_0to2pi(atan2(otherCircle.center - thisRect.center));
            var dist = thisRect.center.dist(otherCircle.center);
            return (dist - otherCircle.r) - rectDist(angle_thisToOther, thisRect);
        }
    }

    function intersects(other: Box[Bound]): Bool {
        var otherRect: Ptr[Rect] = other.base() as Ptr[Rect];
        return !(otherRect.x - otherRect.w > this.x + this.w ||
                otherRect.x + otherRect.w < this.x - this.w ||
                otherRect.y - otherRect.h > this.y + this.h ||
                otherRect.y + otherRect.h < this.y - this.h);
    }

    function print(): Void {
        this.tl.print();
        printf(", ");
        this.tr.print();
        printf(", ");
        this.bl.print();
        printf(", ");
        this.br.print();
        printf("\n");
    }

    function type() {
        return "rect";
    }
}

struct Circle {
    var x: Float;
    var y: Float;
    var r: Float;
    var rSquared: Float;
    var center: Point;

    static function new(x: Float, y: Float, r: Float): Circle {
        var rSquared = r * r;
        return struct Self {
            x,
            y,
            r,
            rSquared,
            center: Point.new(x, y)
        };
    }

    function intersectsRect(other: Rect) {
        var xDist: Float = absF(other.x - this.x);
        var yDist: Float = absF(other.y - this.y);
        var r: Float = this.r;
        var w: Float = other.w;
        var h: Float = other.h;

        var edges: Float = (xDist - w) * (xDist - w) + (yDist - h) * (yDist - h);

        if (xDist > (r + w) || yDist > (r + h)) {
            return false;
        }

        // intersection within the circle
        if (xDist <= w || yDist <= h) {
            return true;
        }

        // intersection on the edge of the circle
        return edges <= this.rSquared;
    }

    function intersectsCircle(other: Circle) {
        var dist = this.center.dist(other.center);
        if (dist - this.r) - other.r < 0 {
            return true;
        } else {
            return false;
        }
    }

    public function base(): Ptr[Void]{
        return &this;
    }
}

implement Bound for Circle {
    function contains(pt: Point): Bool {
        // check if the point is in the circle by checking if the euclidean distance of
        // the point and the center of the circle if smaller or equal to the radius of
        // the circle
        var d: Float = (pt.x - this.x) * (pt.x - this.x) + (pt.y - this.y) * (pt.y - this.y);
        return d <= this.rSquared;
    }

    function dist(other: Box[Bound]): Float {
        if other.type() == "rect" {
            var otherRect: Ptr[Rect] = other.base() as Ptr[Rect];
            var thisCircle: Ptr[Circle] = this.base() as Ptr[Circle];
            var angle_thisToOther = radian_PosNeg_To_0to2pi(atan2(thisCircle.center - otherRect.center));
            // var angle_otherToThis = radian_PosNeg_To_0to2pi(atan2(otherRect.center - thisCircle.center));
            var dist = thisCircle.center.dist(otherRect.center);
            return (dist - thisCircle.r) - rectDist(angle_thisToOther, otherRect);
        }
        if other.type() == "circle" {
            var otherCircle: Ptr[Circle] = other.base() as Ptr[Circle];
            var dist = this.center.dist(otherCircle.center);
            return (dist - this.r) - otherCircle.r;
        }
    }

    function intersects(other: Box[Bound]): Bool {
        if other.type() == "rect" {
            return this.intersectsRect(other.base() as Ptr[Rect]);
        }
        if other.type() == "circle" {
            return this.intersectsCircle(other.base() as Ptr[Circle]);
        }
    }


    function print(): Void {
        this.center.print();
        printf(", âŒ€%f\n", this.r);
    }

    function type() {
        return "circle";
    }
}


struct QuadTree {
    var boundary: Rect;
    var capacity: Int;
    var points: Array;
    var divided: Bool;
    var insertPoint: Int = 0;
    // var children: Children;
    var topright: Ptr[QuadTree];
    var topleft: Ptr[QuadTree];
    var bottomright: Ptr[QuadTree];
    var bottomleft: Ptr[QuadTree];
    var hasBeenInserted: Bool = false;

    static function new(boundary: Rect, capacity: Int) {
        if capacity < 1 {
            capacity = 1;
        }

        return struct Self {
            boundary,
            capacity,
            points: Array.new(capacity),
            divided: false,
            insertPoint: 0
        };
    }

    function subdivide() {
        var x = this.boundary.x;
        var y = this.boundary.y;
        var w = this.boundary.w / 2;
        var h = this.boundary.h / 2;

        var tr: Rect = Rect.new(x + w, y,     w, h);
        var tl: Rect = Rect.new(x,     y,     w, h);
        var br: Rect = Rect.new(x + w, y + h, w, h);
        var bl: Rect = Rect.new(x,     y + h, w, h);

        this.topright = malloc(sizeof QuadTree);
        this.topleft = malloc(sizeof QuadTree);
        this.bottomright = malloc(sizeof QuadTree);
        this.bottomleft = malloc(sizeof QuadTree);

        *this.topright = QuadTree.new(tr, this.capacity);
        *this.topleft = QuadTree.new(tl, this.capacity);
        *this.bottomright = QuadTree.new(br, this.capacity);
        *this.bottomleft = QuadTree.new(bl, this.capacity);

        this.divided = true;
    }

    function insert(pt: Point) {
        // this.boundary.print();
        if (!this.boundary.Bound.contains(pt)) {  // <- in this function call
            // printf("not in\n");
            return false;
        } else {
            // printf("in\n");
            if (this.insertPoint < this.capacity) {
                // pt.print();
                this.points[this.insertPoint] = pt;
                // this.points[this.insertPoint].print();
                this.hasBeenInserted = true;
                // printf(if this.hasBeenInserted then "true\n" else "false\n");
                this.insertPoint++;
                // printf("inserted\n");
                return true;
            } else {
                // printf(if this.hasBeenInserted then "true\n" else "false\n");
                // printf(if this.divided then "true\n" else "false\n");
                if (this.divided == false && this.hasBeenInserted == true) {  // <- as a result of adding && this.hasBeenInserted
                    // if count > 30 {
                    //     exit(EXIT_FAILURE);
                    // }
                    // printf("dividing\n");
                    // this.boundary.print();
                    this.subdivide();
                    // printf("---\n");
                    // this.topright.boundary.print();
                    // this.topleft.boundary.print();
                    // this.bottomright.boundary.print();
                    // this.bottomleft.boundary.print();
                    // printf("----------\n");
                    // count++;
                }
                // printf("subinsert before if\n");
                if (this.topright.insert(pt) ||
                    this.topleft.insert(pt) ||
                    this.bottomright.insert(pt) ||
                    this.bottomleft.insert(pt)) {
                        // printf("subinsert\n");
                        return true;
                }
            }
        }
        return false;
    }

    function query(boundary: Box[Bound]): Vector[Point] {
        if (!boundary.intersects(this.boundary)) {
            return Vector.new();
        }

        var found: Vector = Vector.new();

        for p in this.points {
            if (boundary.contains(p)) {
                found.push(p);
            }
        }

        if (this.divided) {
            var tl: Vector[Point] = this.topleft.query(boundary);
            if (tl.length != 0) {
                for m in 0 ... tl.length {
                    if tl[m].initialized {
                        found.push(tl[m]);
                        // tl[m].print(true, " tl\n");
                    }
                }
            }
            var tr: Vector[Point] = this.topright.query(boundary);
            if (tr.length != 0) {
                for m in 0 ... tr.length {
                    if tr[m].initialized {
                        found.push(tr[m]);
                        // tr[m].print(true, " tr\n");
                    }
                }
            }
            var bl: Vector[Point] = this.bottomleft.query(boundary);
            if (bl.length != 0) {
                for m in 0 ... bl.length {
                    if bl[m].initialized {
                        found.push(bl[m]);
                        // bl[m].print(true, " bl\n");
                    }
                }
            }
            var br: Vector[Point] = this.bottomright.query(boundary);
            if (br.length != 0) {
                for m in 0 ... br.length {
                    if br[m].initialized {
                        found.push(br[m]);
                        // br[m].print(true, " br\n");
                    }
                }
            }
        }
        return found;
    }

    function debugDivided(prefix: CString = "") {
        if this.divided {
            printf("%s", prefix);
            printf("true\n");
            var nextPrefix = strAdd("|..", prefix);
            this.topright.debugDivided(nextPrefix);
            this.topleft.debugDivided(nextPrefix);
            this.bottomright.debugDivided(nextPrefix);
            this.bottomleft.debugDivided(nextPrefix);
        } else {
            printf("%s", prefix);
            printf("false\n");
        }
    }

    function debugValues(prefix: CString = "") {
        if this.divided {
            for n in 0 ... this.capacity {
                printf("%s", prefix);
                this.points[n].print();
                printf("\n");
            }
            var nextPrefix = strAdd("|..", prefix);
            this.topright.debugValues(nextPrefix);
            printf("%s|\n", prefix);
            this.topleft.debugValues(nextPrefix);
            printf("%s|\n", prefix);
            this.bottomright.debugValues(nextPrefix);
            printf("%s|\n", prefix);
            this.bottomleft.debugValues(nextPrefix);
        } else {
            for n in 0 ... this.capacity {
                printf("%s", prefix);
                this.points[n].print();
                printf("\n");
            }
        }
    }
}


function main() {
    var canvas = Rect.new(0, 0, 20, 20);
    var qtree: QuadTree = QuadTree.new(canvas, 4);
    // qtree.boundary.print();
    for n in 0 ... 50 {
        qtree.insert(Point.new(randF(0, 20), randF(0, 20)));
    }
    // qtree.insert(Point.new(1, 1));
    // qtree.insert(Point.new(2, 14));
    // qtree.insert(Point.new(7, 5));
    // qtree.insert(Point.new(3, 2));
    // qtree.insert(Point.new(2, 3));
    // qtree.insert(Point.new(2, 5));
    // qtree.insert(Point.new(8, 13));
    // qtree.insert(Point.new(6, 1));
    qtree.debugValues();
    var select = Rect.new(0, 0, 7, 7);
    var selected: Vector[Point] = qtree.query(select);
    printf("\n");
    printf("%zu\n", selected.length);
    // printf(selected);
    for m in selected {
        m.print(true, "\n");
    }
    var select2 = Circle.new(10, 10, 4);
    var selected2: Vector = qtree.query(select2);
    printf("\n");
    for p in 0 ... selected2.length {
        selected2[p].print(true, "\n");
    }
}
